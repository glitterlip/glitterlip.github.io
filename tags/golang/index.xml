<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>golang on 代码笔记</title>
    <link>https://glitterlip.github.io/tags/golang/</link>
    <description>Recent content in golang on 代码笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zn-Hans</language>
    <lastBuildDate>Sat, 15 Oct 2022 19:46:21 +0800</lastBuildDate><atom:link href="https://glitterlip.github.io/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>grpc笔记</title>
      <link>https://glitterlip.github.io/blog/2022-10/grpc%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sat, 15 Oct 2022 19:46:21 +0800</pubDate>
      
      <guid>https://glitterlip.github.io/blog/2022-10/grpc%E7%AC%94%E8%AE%B0/</guid>
      <description>版本 go version go1.19.1 darwin/arm64 protoc --version libprotoc 3.19.4 package protoc-gen-go --version //用于生成xx.pb.go 即grpc go语言版本的代码 protoc-gen-go v1.28.1 protoc-gen-go-grpc --version //用于生成xx_grpc.pb.go 即grpc服务service相关代码 protoc-gen-go-grpc 1.2.0 目录 helloworld/ ├── client.go - 客户端代码 ├── go.mod - go模块配置文件 ├── proto - 协议目录 │ ├── helloworld.pb.go - rpc协议go版本代码 命令生成 │ ├── helloworld_grpc.pb.go - rpc协议go版本代码 命令生成 │ └── helloworld.proto - rpc协议文件 └── server.go - rpc服务端代码 helloworld.proto syntax = &amp;#34;proto3&amp;#34;; // 定义包名 package proto; option go_package</description>
    </item>
    
    <item>
      <title>gin打包html模板和静态资源文件</title>
      <link>https://glitterlip.github.io/blog/2022-09/gin%E6%89%93%E5%8C%85html%E6%A8%A1%E6%9D%BF%E5%92%8C%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6/</link>
      <pubDate>Sun, 18 Sep 2022 01:26:18 +0800</pubDate>
      
      <guid>https://glitterlip.github.io/blog/2022-09/gin%E6%89%93%E5%8C%85html%E6%A8%A1%E6%9D%BF%E5%92%8C%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6/</guid>
      <description>[GIN-debug] [WARNING] Since SetHTMLTemplate() is NOT thread-safe. It should only be called at initialization. ie. before any route is registered or the router is listening in a socket: router := gin.Default() router.SetHTMLTemplate(template) // &amp;lt;&amp;lt; good place Gin和Echo有点不一样，需要在注册路由之前注册模板 注册子目录的html文件 ├── go.mod ├── go.sum ├── app.go ├── resources │ ├── css │ │ └── input.css │ ├── js │ │ └── tailwind.config.js │ └── views │ ├── detail.html │ ├── home │ │ └── home.index.html │ └── search.html func walkDir(fileSystem embed.FS, path string) { _, err := T.ParseFS(fileSystem, path+&amp;#34;/*.html&amp;#34;) if err != nil { panic(fmt.Sprintf(&amp;#34;parse error:%s&amp;#34;, err.Error())) } entries, _ := fs.ReadDir(fileSystem, path) for _, entry := range entries { if entry.IsDir() { walkDir(fileSystem, path+&amp;#34;/&amp;#34;+entry.Name()) } } } T:=template.New(&amp;#34;view&amp;#34;) T.ParseFS(ResourcesFS, &amp;#34;resources/views/*.html&amp;#34;) entries, _ := ResourcesFS.ReadDir(&amp;#34;resources/views&amp;#34;) for _, entry := range entries { if entry.IsDir() { walkDir(ResourcesFS, &amp;#34;resources/views/&amp;#34;+entry.Name()) } }</description>
    </item>
    
    <item>
      <title>Golang Echo,React Umijs 项目部署</title>
      <link>https://glitterlip.github.io/blog/2022-08/golang-echoreact-umijs-%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/</link>
      <pubDate>Thu, 18 Aug 2022 15:30:31 +0800</pubDate>
      
      <guid>https://glitterlip.github.io/blog/2022-08/golang-echoreact-umijs-%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/</guid>
      <description>nginx 配置文件 server { #强制https listen 80; listen [::]:80; server_name project.com; return 301 https://project.com$request_uri; } map $http_upgrade $connection_upgrade { default upgrade; &amp;#39;&amp;#39; close; } server { listen 443 ssl; ssl_certificate /etc/letsencrypt/live/project.com/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/project.com/privkey.pem; server_name project.com; #默认为umijs 构建产物 location / { root /data/project/project/public/dist; index index.html index.htm; try_files $uri $uri/ /index.html; } location /api { # golang后端api监听18081端口 proxy_pass http://127.0.0.1:18081/api; proxy_set_header Upgrade $http_upgrade; #websocket 链接 proxy_set_header Connection $connection_upgrade; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; } error_log /var/log/nginx/project_error.log; access_log /var/log/nginx/project_access.log; } k8s服务器在国内，这个项目服务器在香港，ci/cd的话直接上传构建产物了，git只作为代码追踪使用 golang echo 部署脚本 #! /bin/bash #打包压缩 GOOS=linux GOARCH=amd64 go build -o project &amp;amp;&amp;amp; zip project.zip project #scp上传</description>
    </item>
    
    <item>
      <title>golang mysql设置时区</title>
      <link>https://glitterlip.github.io/snippet/mysql-loc/</link>
      <pubDate>Sat, 06 Aug 2022 11:14:43 +0800</pubDate>
      
      <guid>https://glitterlip.github.io/snippet/mysql-loc/</guid>
      <description>github.com/go-sql-driver包设置时区 DSN方式追加loc参数，值必须转义,/用%2F替换 DSN: parseTime=true&amp;amp;loc=Asia%2FShanghai</description>
    </item>
    
    <item>
      <title>golang template函数传递多个参数</title>
      <link>https://glitterlip.github.io/blog/2022-07/golang-template%E5%87%BD%E6%95%B0%E4%BC%A0%E9%80%92%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0/</link>
      <pubDate>Tue, 19 Jul 2022 09:53:11 +0800</pubDate>
      
      <guid>https://glitterlip.github.io/blog/2022-07/golang-template%E5%87%BD%E6%95%B0%E4%BC%A0%E9%80%92%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0/</guid>
      <description>golang开发web页面时，会把页面的公共部分抽离出来，定义成组件 比如定义一个header，然后其他页面就无需再重复写了，直接引入即可 //header.html {{define &amp;#34;header&amp;#34;}} this is header. Current User:{{.user.Name}} {{end}} //detail.html {{template &amp;#34;header&amp;#34; .user}} 但是此时如果你想再展示天气，你可以定义一个UserWithWeather，这就有点不伦不类了 我们可以定义一个map模板函数 template.New(&amp;#34;view&amp;#34;).Funcs(template.FuncMap{ &amp;#34;mapof&amp;#34;: func(kvpairs ...interface{}) (map[string]interface{}, error) { if len(kvpairs)%2 != 0 { return nil, errors.New(&amp;#34;wrong number of arguements&amp;#34;) } dict := make(map[string]interface{}, len(kvpairs)/2) for i := 0; i &amp;lt; len(kvpairs); i += 2 { key, ok := kvpairs[i].(string) if !ok { return nil, errors.New(&amp;#34;map keys must be strings&amp;#34;) } dict[key] = kvpairs[i+1] } return dict, nil }, })</description>
    </item>
    
    <item>
      <title>golang cron包计划任务不执行</title>
      <link>https://glitterlip.github.io/blog/2022-07/golang-cron%E5%8C%85%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%E4%B8%8D%E6%89%A7%E8%A1%8C/</link>
      <pubDate>Mon, 18 Jul 2022 09:53:11 +0800</pubDate>
      
      <guid>https://glitterlip.github.io/blog/2022-07/golang-cron%E5%8C%85%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%E4%B8%8D%E6%89%A7%E8%A1%8C/</guid>
      <description>cron包旧版本中的表达式和常见的linux crontab表达式并不一致， 多了一个秒级别的定时，新版本中v3已经移除了 如果你在使用github.com/robfig/cron/v3这个包的时候遇到计划任务未执行可能是这个原因 使用秒级定时器 c:=cron.New(cron.WithSeconds()) c.AddFunc(&amp;#34;0 30 * * * *&amp;#34;, func() { fmt.Println(&amp;#34;Every hour on the half hour&amp;#34;) }) 不需要秒级定时器 c:=cron.New() c.AddFunc(&amp;#34;30 * * * *&amp;#34;, func() { fmt.Println(&amp;#34;Every hour on the half hour&amp;#34;) })</description>
    </item>
    
  </channel>
</rss>
